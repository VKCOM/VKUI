# Гайд по написанию стилей

## Соглашения

- Используем БЭМ-нотацию
- Блок начинается с заглавной буквы: `.Checkbox`
- Многословный блок разделяется через camelCase: `.ButtonGroup`
- Элемент от блока отделяется двумя подчеркиваниями: `.Checkbox__in`
- Многословные элементы разделяются через kebab-case: `.Banner__before-title`
- Модификатор отделяется двумя дефисами: `.Input--plain`
- Многословные модификаторы разделяются через kebab-case или camelCase: `.Checkbox--sizeX-regular`

### Связность стилей

Если компонент состоит из других компонентов, то для их модификации используем БЭМ-миксин. Пример:

```tsx
// Button.tsx
<button className={styles.Button}>
  <Text className={styles.Button__text}>{children}</Text>
</button>
```

```css
/* Button.css */
.Button__text {
  margin: 4px 0;
}
```

Если в компонент прокидываются другие компоненты извне, то для их модификации используем обращение к блоку. Пример:

```tsx
// Cell.tsx
<div className={styles.Cell}>
  {before} {/* В before может быть <Icon /> или <Avatar /> */}
</div>
```

```css
/* Cell.css */
.Cell .Icon {
  margin-right: 10px;
}

.Cell .Avatar {
  margin-right: 8px;
}
```

Таких ситуаций стоит избегать, так как подобное связывание лишает нас возможности в будущем хешировать имена классов с
помощью css-modules.

## Классы с префиксом `vkui`

Класс, который начинается с `vkui`, обозначает, что он глобальный. Например
`vkuiIcon` – классы иконок из `@vkontakte/icons`.

В файлах `*.module.css` они должны быть обёрнуты в [`:global(.xxx)`](https://github.com/css-modules/css-modules#exceptions),
чтобы CSS Modules не трогал их.

## Проблемы

### Конфликт стилей блока и миксина

```css
/* Text.css */
.Text {
  margin: 0;
}
```

```css
/* Button.css */
.Button__text {
  margin: 4px 0;
}
```

Вес селекторов одинаковый, поэтому применится последний по порядку. Рассчитывать на порядок сложно, так как он может
меняться, если собирать стили вебпаком.

#### Решение

Избегать правил на блоке, которые могут быть в миксине.

Список правил, которых стоит избегать:

- display;
- margin;
- position;
- left, right, top, bottom;
- transform: translate

### Сброс стилей

Допустим, мы делаем компонент типографики. Для семантики мы даём возможность рендерить
любой html-элемент. В итоге, если пользователь рендерит, допустим, `h1`, у него появляются
дефолтные браузерные `margin`. Наше решение такое:

```css
/* Title.css */

.Title {
  /*...*/
  margin: 0; /* или любое другое значение, диктуемое дизайном */
}
```

Решение приводит нас к предыдущей проблеме.

#### Решение

В таком случае необходимо снабдить компонент режимом `withSpaces`, который
если `false`, то никакие `margin` на блок не навешиваются.

### Нормализация стилей

Допустим, мы делаем компонент кнопки. Согласно дизайну, кнопка может быть ссылкой. Поэтому
Button мы тоже наделяем возможностью рендерить любой html-элемент, в том числе `a`. В силу
ряда стилей нам необходимо, что кнопка не была инлайновой. Поэтому мы пишем следующее:

```css
/* Button.css */

.Button {
  /* ... */
  display: inline-block;
}
```

Теперь те, кто хочет скрыть кнопку, используя миксин, столкнутся с проблемой конфликта
блока и миксина.

#### Решение

В данном случае мы можем только порекомендовать разработчикам оборачивать кнопку
в условный `div`.

### Обращения к элементам другого блока

```css
/* Banner.css */
.Banner .Button__in {
  padding-top: 4px;
}
```

Мы завязываемся на реализацию другого компонента. Это плохо, так как реализация может меняться.

#### Решение

Не обращаться к элементам другого блока

Для поддержки старого кода в некоторых местах используются глобальные классы `vkuiInternal*`.
От них следует избавляться.
