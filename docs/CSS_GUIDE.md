# Гайд по написанию стилей

## Соглашения

### Используйте camelCase для имён классов

Для всех `.module.css` файлов активирован линтер, который проверяет, чтобы локальные классы были в camelCase . Именно эти классы затем будут импортировать в JS и именно они затем будут отображаться в инспекторе браузера, если вы решите посмотреть какой-то элемент. Такой формат выбран в том числе для удобства написания и отладки кода.

### Модификаторы

У модификаторов элемента должен быть префикс с названием этого элемента. Например,

```css
.container {
}
.containerPrimary {
}
.containerSecondary {
}

.text {
}
.textWithShadow {
}
```

## Классы с префиксом `vkui`

Класс, который начинается с `vkui`, обозначает, что он глобальный. Например
`vkuiIcon` – классы иконок из `@vkontakte/icons`.

В файлах `*.module.css` они должны быть обёрнуты в [`:global(.xxx)`](https://github.com/css-modules/css-modules#exceptions),
чтобы CSS Modules не трогал их.

## Проблемы

### Конфликт стилей блока и миксина

```css
/* Text.css */
.host {
  margin: 0;
}
```

```css
/* Button.css */
.text {
  margin: 4px 0;
}
```

Вес селекторов одинаковый, поэтому применится последний по порядку. Рассчитывать на порядок сложно, так как он может
меняться, если собирать стили вебпаком.

#### Решение

Избегать правил на блоке, которые могут быть в миксине.

Список правил, которых стоит избегать:

- display;
- margin;
- position;
- left, right, top, bottom;
- transform: translate

### Сброс стилей

Допустим, мы делаем компонент типографики. Для семантики мы даём возможность рендерить
любой html-элемент. В итоге, если пользователь рендерит, допустим, `h1`, у него появляются
дефолтные браузерные `margin`. Наше решение такое:

```css
/* Title.css */

.title {
  /*...*/
  margin: 0; /* или любое другое значение, диктуемое дизайном */
}
```

Решение приводит нас к предыдущей проблеме.

#### Решение

В таком случае необходимо снабдить компонент режимом `withSpaces`, который
если `false`, то никакие `margin` на блок не навешиваются.

### Нормализация стилей

Допустим, мы делаем компонент кнопки. Согласно дизайну, кнопка может быть ссылкой. Поэтому
Button мы тоже наделяем возможностью рендерить любой html-элемент, в том числе `a`. В силу
ряда стилей нам необходимо, что кнопка не была инлайновой. Поэтому мы пишем следующее:

```css
/* Button.css */
.button {
  /* ... */
  display: inline-block;
}
```

Теперь те, кто хочет скрыть кнопку, используя миксин, столкнутся с проблемой конфликта
блока и миксина.

#### Решение

В данном случае мы можем только порекомендовать разработчикам оборачивать кнопку
в условный `div`.

### Обращения к элементам другого блока

```css
/* Banner.module.css */
:global(.vkuiBanner) :global(.vkuiButtonIn) {
  padding-top: 4px;
}
```

Мы завязываемся на реализацию другого компонента. Это плохо, так как реализация может меняться.

#### Решение

Не обращаться к элементам другого блока

Для поддержки старого кода в некоторых местах используются глобальные классы `vkuiInternal*`.
От них следует избавляться.
