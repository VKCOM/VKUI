# Руководство по сопровождению VKUI

Данный документ содержит базовую информацию по сопровождению и процессам разработки и будет полезен в первую очередь
сопровождающим (maintainers) репозитория **VKUI**. Информацию по правилам работы с кодом можно найти в
[требованиях к разработке](https://github.com/VKCOM/VKUI/blob/master/docs/CONTRIBUTING.md).

## Глоссарий

Для консистентности следует использовать следующие термины:

- `свойство` (вместо `параметр`)
- `под-компонент` (вместо `сабкомпонент`)

## Issues

Часть работы сопровождающих заключается в разметке новых [issues](https://github.com/VKCOM/VKUI/issues). Нужно обращать
внимание на следующие поля:

- **Assignees**: заполняется тем, кто берет `issue` в работу
- **Labels**: обязательно для заполнения. Если при создании `issue` был указан
  [шаблон](https://github.com/VKCOM/VKUI/issues/new/choose) - `bug`, `feature`, `docs` - тогда в поле `Labels` тэг
  проставится автоматически. Также в `Labels` указывается название компонента, к которому относится доработка - искать
  необходимо по `cmp:название-компонента` (вероятнее всего, что нужный тэг [уже создан](https://github.com/VKCOM/VKUI/labels?q=cmp%3A)).
- **Projects**: обязательно для заполнения. Указывается **VKUI** (здесь же можно выбрать/поменять текущий статус
  задачи).
- **Milestone**: ближайший релиз, в который попадет задача (заполнять это поле нужно только в случае, если вы уверены,
  что решение в этот релиз попадёт и повлияет на конечный артефакт библиотеки - технические задачи, например, обновление
  правил `eslint`, указывать не нужно).

> Примеры корректно оформленных `issues`:
>
> - [Bug](https://github.com/VKCOM/VKUI/issues/6715)
> - [Feature](https://github.com/VKCOM/VKUI/issues/6849)
> - [Docs](https://github.com/VKCOM/VKUI/issues/6949)

Если на созданную `issue` получается дать ответ сразу же или исправление не требуется/не подразумевается, то необходимо
заполнить поля **Assignees** и **Projects** и закрыть с соответствующим комментарием через кнопку `Close as not planned`.

Если `issue` больше похоже на вопрос по работе библиотеки или тему, требующую обсуждений, то можно перевести `issue` в
[Дискуссию](https://github.com/VKCOM/VKUI/discussions), нажав кнопку `Convert to discussion` в нижней части меню справа.

Если `issue` требует каких-то дополнительных разъяснений, то рекомендуется запросить их, заполнить поля **Assignees** и
**Projects** (можно проставить статус задачи в `Blocked`), в поле `Labels` проставить значение `issue-needs-more-info`.
Это позволит отработать автоматизации, которая закроет подобный `issue` автоматически в случае отсутствия активности в
течение 14 дней.

> ⚠️ Обратите внимание
>
> Иногда при создании `issue` автор по ошибке может указать чувствительные данные. В таком случае воспрользуйтесь
> [инструкцией](https://docs.github.com/en/communities/moderating-comments-and-conversations/tracking-changes-in-a-comment#deleting-sensitive-information-from-a-comments-history)
> по удалению этой информации.

## Pull Requests

При создании нового `Pull Request` в описании уже подтянется шаблон, который нужно будет заполнить. Обычно `Pull Request`
решает `issue` - ссылку на неё нужно указать через [ключевые слова](https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/using-keywords-in-issues-and-pull-requests).
Если `PR` не имеет `issue`, то наиболее полное описание проблемы/доработки должно содержаться в описании этого `PR`,
а также необходимо будет заполнить все поля по аналогии с `Issues`.

- если работа над `PR` ещё ведется, рекомендуется перевести его в
  [draft](https://docs.github.com/ru/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/changing-the-stage-of-a-pull-request#converting-a-pull-request-to-a-draft).
- существует автоматизация, которая закрывает `PR` в случае 2х-недельного отсутствия в нем активности. В случае
  продолжительной работы над каким-то `PR` рекомендуется проставить ему в поле `Labels` значение `no-stale` для
  игнорирования автоматизации.
- название `PR` обычно автоматически подставляется со сделанного `commit`. Необходимо придерживаться [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0-beta.2/#summary), в таком случае будут срабатывать
  автоматизации, например, если название в шапке `PR` начинается с `fix`, то проставится в поле `Labels` значение
  `patch` для автоматического дублирования кода в ветку для патч-изменений.

## Создание патч-изменений

При разработке мы опираемся на [GitLab Flow](https://docs.gitlab.co.jp/ee/topics/gitlab_flow.html#release-branches-with-gitlab-flow).
Подробнее можно почитать в [этом PR](https://github.com/VKCOM/VKUI/pull/2759).

Кратко:

- основную разработку ведем в ветке `master` (ветка планируемого минорного релиза), от неё создаём свои ветки и в неё же
  отправляем все изменения.
- при публикации минорного релиза `x.y.0` автоматически создается ветка `x.y-stable` для патчей (например, при
  публикации минорной версии 6.1.0 будет создана ветка для последующих патчей 6.1-stable).
- если в `PR` указать в `Labels` значение `patch` (происходит автоматически, если название в шапке `PR` начинается с `fix`),
  то изменения продублируются и в `x.y-stable`.
- если изменения по какой-то причине автоматически не продублировались, то необходимо их перенести вручную (инструкция
  будет в исходном `PR`).

## Формирование Release Notes (актуально для VKUI)

> Примеры эталонных `Release Notes`:
>
> - [патч-изменение](https://github.com/VKCOM/VKUI/releases/tag/v6.0.3)
> - [минорное изменение](https://github.com/VKCOM/VKUI/releases/tag/v6.7.0).

Для каждого релиза **VKUI** подготавливается черновой [список изменений](https://github.com/VKCOM/VKUI/releases) – название списка
соответствует полю `Milestone`, указанному в задаче. В него попадают описания тех задач, которые напрямую влияют на конечный
артефакт библиотеки (технические задачи, такие как обновление правил `eslint`, не являются такими). Помимо описания, каждый пункт
списка содержит ссылку на его `Pull Request`.

Черновик создаётся автоматически, как только происходит слияние первого `Pull Request` для версии из `Milestone`, далее пополняется
до тех пор, пока не закончится работа над версией. Список формируется за счёт раздела `## Release Notes` в описании
`Pull Request`'а (см. [.github/pull_request_template.md](../.github/pull_request_template.md)).

> ⚠️ Обратите внимание
>
> Несмотря на то, что черновой список изменений создаётся и обновляется автоматически при слиянии `Pull Request`, бывают случае,
> когда нужно вручную добавить или отредактировать изменение. Тогда нужно учитывать, что ссылка на черновик меняется после каждого
> его сохранения. Поэтому если вносить изменения одновременно с кем-то, то последний сохранивший документ получит ошибку, что он уже
> неактуален. В этом случае, нужно будет открыть черновик по новой ссылке и снова внести свои изменения.
>
> Чтобы избежать таких неудобств, лучше всего сообщить коллегам в чате, что вы собираетесь вносить изменения, а после, отписаться,
> что вы закончили работы.

## Подготовка и выпуск релизов

### Релиз VKUI

Для того, чтобы выпустить версию библиотеки VKUI, необходимо придерживаться следующего чек-листа:

- [ ] создан [`Milestone`](https://github.com/VKCOM/VKUI/milestones) с названием планируемого релиза (например, `v6.2.0`), все
      связанные с ним задачи находятся в состоянии `Closed`.
- [ ] создан [`Release notes`](https://github.com/VKCOM/VKUI/releases) с названием планируемого релиза (например, `v6.2.0`), в нем
      описаны все задачи, включенные в соответствующий `Milestone`.
- [ ] дополнительно пройтись по коммитам в публикуемой ветке, чтобы убедиться, что все задачи попали в `Milestone`/`Release notes`.
- [ ] в чате сопровождающих оповестить о планируемом релизе

Для непосредственного запуска релизов и пререлизов (`alpha`/`beta`-версии) используются Github Actions. Запуск осуществляется
со [страницы релиза](https://github.com/VKCOM/VKUI/actions/workflows/publish.yml) или [страницы пререлиза](https://github.com/VKCOM/VKUI/actions/workflows/publish_prerelease.yml).
Выпуск пререлиза обычно не подразумевает наличие `Milestone`/`Release Notes`, поэтому этих шагов в процессе не будет,
но будет возможность указать `npm`-тэги (`alpha`, `beta`, `rc`). В остальном поля ничем не отличаются, а разделение было
сделано для того, чтобы не перегружать форму с полями.

- **Use workflow from**: выбираем базовую ветку, из которой будет запущен релиз. Для выпуска **VKUI** минорных версий
  это будет `master`, для патчей - соответствующая `stable`-ветка.

- **package's name**: для **VKUI** поле будет `@vkontakte/vkui`.

- **version type**: выбираем тип релиза - патч, минор или мажор. Обычно для **VKUI** выпуск из `stable`-ветки
  соответствует изменениям типа `patch`, из `master` - `minor`.

- **use syntax x.y.z...**: данное поле может быть полезно, если вам необходимо выпустить кастомную версию, которая не
  подчиняется релизному циклу.

- **whether to close associated...**: включенный флаг позволяет в автоматическом режиме закрывать соответствующий релизу
  `Milestone` (все задачи, включенные в этот `Milestone`, получат комментарий-уведомление о вышедшем релизе). Актуально
  только для релиза **VKUI**.

- **set latest tag**: помечает опубликованный релиз в `npm` тэгом `latest` (проставляет такой же тэг в соответствующем
  `Release Notes`).

### Релиз других пакетов

Выпуск [других пакетов](https://github.com/VKCOM/VKUI/tree/master/packages) монорепозитория обычно осуществляется из
`master`-ветки (или специальной ветки, которая содержит необходимые изменения). `Milestone` и `Release Notes` обычно не создаются,
но из требований к выпуску - уведомить в чате сопровождающих о планируемом релизе.

## Полезные автоматизации

Полный список доступных автоматизаций можно найти на [соответствующей странице](https://github.com/VKCOM/VKUI/actions),
вот описание нескольких наиболее полезных:

- [Deduplicate dependencies](https://github.com/VKCOM/VKUI/actions/workflows/dedupe_deps.yml): позволяет запустить
  дедупликацию зависимостей в ветке. Если безопасно вносить изменения в ветку напрямую, то можно отметить `push directly to the branch`,
  иначе будет создан `PR` с изменениями в выбранную ветку. Бывает полезно запускать эту автоматизацию после обновления
  зависимостей в ветке - у нас настроен [Dependabot](https://docs.github.com/en/code-security/getting-started/dependabot-quickstart-guide),
  который [обновляет зависимости](https://github.com/VKCOM/VKUI/blob/master/.github/dependabot.yml) в начале каждой недели.
- [Update screenshots](https://github.com/VKCOM/VKUI/actions/workflows/update_screens.yml): данная автоматизация
  позволяет запускать обновление скриншотов в выбранной ветке вручную (если вы забыли это сделать локально, например),
  а так же отвечает за обновление скриншотов в `stable`-ветках в автоматическом режиме (потому что мы не дублируем
  обновление скриншотов из `master` в `stable`-ветки из-за возможных отличий).
- [Close inactive issues and PRs](https://github.com/VKCOM/VKUI/actions/workflows/inactive_contributions.yml): автоматизация
  закрывает устаревшие `issues` и `PRs`.
