import{j as c,a1 as ie,i as ke,v as ce,r as s,h as Te,g as Le,T as je,as as de,K as p,aq as B,b1 as Me,ap as pe}from"./iframe-CGSrC79H.js";import{F as Pe}from"./FormField-CQtfDQHY.js";import{I as He}from"./IconButton-Bq_FXaCp.js";import{I as we}from"./cancel_16--_Pgj7hA.js";import{u as ze,a as Se}from"./useEnsuredControl-AiFtRieF.js";import{u as Ye}from"./useNativeFormResetListener-DbeuhCJS.js";import{C as Ke}from"./Chip-FHlVGN2M.js";function Ce(e){return e?e.replace(/([.*+?^${}()|[\]\/\\])/g,"\\$1"):""}const X=({className:e,onClick:t,...l})=>c.jsx(He,{Component:"button",label:"Очистить поле",onKeyDown:ie,type:"button",activeMode:"opacity",hoverMode:"opacity",...l,className:e,onClick:a=>{ie(a),a.preventDefault(),t()},children:c.jsx(we,{})});try{X.displayName="FormFieldClearButton",X.__docgenInfo={description:"",displayName:"FormFieldClearButton",props:{className:{defaultValue:null,description:"`className` для компонента.",name:"className",required:!1,type:{name:"string"}},onClick:{defaultValue:null,description:"Обработчик нажатия на кнопку.",name:"onClick",required:!0,type:{name:"() => void"}},disabled:{defaultValue:null,description:"Блокировка взаимодействия с компонентом.",name:"disabled",required:!1,type:{name:"boolean"}}}}}catch{}const J=[],S="";function Q(e){return e.value}function Z(e){return e.label}function $e(e,t){return{value:e,label:t}}function ee(e){const{label:t,...l}=e;return c.jsx(Ke,{removable:!e.disabled,...l,children:t})}try{Q.displayName="getOptionValueDefault",Q.__docgenInfo={description:"",displayName:"getOptionValueDefault",props:{value:{defaultValue:null,description:"Значение опции.",name:"value",required:!0,type:{name:"ChipOptionValue"}},label:{defaultValue:null,description:"Отображаемый текст опции.",name:"label",required:!0,type:{name:"ChipOptionLabel"}},disabled:{defaultValue:null,description:"Блокировка взаимодействия с оцией.",name:"disabled",required:!1,type:{name:"boolean"}}}}}catch{}try{Z.displayName="getOptionLabelDefault",Z.__docgenInfo={description:"",displayName:"getOptionLabelDefault",props:{value:{defaultValue:null,description:"Значение опции.",name:"value",required:!0,type:{name:"ChipOptionValue"}},label:{defaultValue:null,description:"Отображаемый текст опции.",name:"label",required:!0,type:{name:"ChipOptionLabel"}},disabled:{defaultValue:null,description:"Блокировка взаимодействия с оцией.",name:"disabled",required:!1,type:{name:"boolean"}}}}}catch{}try{ee.displayName="renderChipDefault",ee.__docgenInfo={description:"",displayName:"renderChipDefault",props:{label:{defaultValue:null,description:"Отображаемый текст чипа.",name:"label",required:!0,type:{name:"ChipOptionLabel"}},mode:{defaultValue:null,description:"Режим отображения компонента.",name:"mode",required:!1,type:{name:"enum",value:[{value:'"primary"'},{value:'"secondary"'}]}},value:{defaultValue:null,description:"Значение чипа.",name:"value",required:!1,type:{name:"ChipOptionValue"}},removable:{defaultValue:null,description:"Можно ли удалить чип.",name:"removable",required:!1,type:{name:"boolean"}},disabled:{defaultValue:null,description:"Блокировка взаимодействия с чипом.",name:"disabled",required:!1,type:{name:"boolean"}},readOnly:{defaultValue:null,description:"Режим только для чтения.",name:"readOnly",required:!1,type:{name:"boolean"}},removeLabel:{defaultValue:null,description:"Текст для кнопки удаления.",name:"removeLabel",required:!1,type:{name:"string"}},before:{defaultValue:null,description:"Контент перед основным содержимым.",name:"before",required:!1,type:{name:"ReactNode"}},after:{defaultValue:null,description:"Контент после основного содержимого.",name:"after",required:!1,type:{name:"ReactNode"}},onRemove:{defaultValue:null,description:"Обработчик удаления чипа.",name:"onRemove",required:!1,type:{name:"((event: MouseEvent<Element, MouseEvent>, value: ChipOptionValue) => void)"}},Component:{defaultValue:null,description:"",name:"Component",required:!1,type:{name:"ElementType<any, keyof IntrinsicElements>"}},getRootRef:{defaultValue:null,description:"",name:"getRootRef",required:!1,type:{name:"Ref<HTMLElement>"}}}}}catch{}const ye=e=>typeof e=="object"&&"value"in e,fe=e=>e?e.value===S:!0,Ue=(e,t)=>{const l=ye(e)?e.value:e;return t.findIndex(a=>a.value===l)},G=e=>{const t=e&&e.dataset.index;return typeof t=="string"?Number(t):-1},We=e=>{const t=e&&e.dataset.value;return(e&&e.dataset.valueType)==="number"?Number(t):typeof t=="string"?t:-1},Ge=(e,t,l)=>{const a=l-1;switch(t){case"prev":const f=e-1;return f<0?a:f;case"next":const C=e+1;return C>a?0:C;case"last":return a;case"first":return 0;default:return-1}},Xe="_host_j893j_1",Je="_listBox_j893j_16",Qe="_chip_j893j_25",Ze="_el_j893j_30",eu="_hasPlaceholder_j893j_44",uu="_hasInputValue_j893j_45",tu="_sizeYCompact_j893j_79",nu="_sizeYNone_j893j_84",b={host:Xe,listBox:Je,chip:Qe,el:Ze,hasPlaceholder:eu,hasInputValue:uu,sizeYCompact:tu,sizeYNone:nu},au={none:b.sizeYNone,compact:b.sizeYCompact},me=({getRef:e,before:t,after:l,status:a,mode:f,maxHeight:C,value:O=J,onAddChipOption:k,onRemoveChipOption:Y,renderChip:T=ee,inputValue:I=S,addOnBlur:K,onInputChange:y,autoFocus:g,disabled:$,readOnly:x,onFocus:h,onBlur:R,id:q,placeholder:L,ClearButton:j=X,clearButtonShown:M,clearButtonTestId:P,onClear:H,chipsListLabel:U="Выбранные элементы","aria-label":r="",slotProps:m,..._})=>{const{sizeY:v="none"}=ke(),{onClick:A,onMouseDown:D,...i}=ce(_,m?.root),{getRootRef:w,onBlur:F,placeholder:he,readOnly:N,disabled:E,id:Ee,value:ue=S,...be}=ce({getRootRef:e,className:b.el,value:I,onChange:y,disabled:$,readOnly:x,onFocus:h,onBlur:R,id:q,placeholder:L,autoFocus:g},m?.input),ge=s.useId(),o=Te(w),Re=s.useRef(null),d=s.useRef(null),V=O.length,te=V===0,[Ve,ne]=s.useState(0),ae=u=>{ne(0),u.focus()},z=(u,n,Ne)=>{const oe=Ge(u,n,V),se=Ne.querySelector(`[data-index="${oe}"]`);se&&(ne(oe),se.focus())},le=(u,n)=>{!o.current||!d.current||(V>1?n===V-1?z(n,"prev",d.current):z(n,"next",d.current):ae(o.current),Y(u))},_e=u=>{const n=u.target;if(!(u.defaultPrevented||!d.current||!de(n)))switch(u.key){case p.ENTER:{!N&&B(n,o.current)&&o.current&&!fe(o.current)&&(u.preventDefault(),k(o.current.value));break}case p.DELETE:case p.BACKSPACE:{!N&&V>0&&(B(n,o.current)?u.key===p.BACKSPACE&&fe(o.current)&&(u.preventDefault(),z(G(n),"last",d.current)):(u.preventDefault(),le(We(n),G(n))));break}case p.HOME:case p.END:case p.ARROW_UP:case p.ARROW_LEFT:case p.ARROW_DOWN:case p.ARROW_RIGHT:{V!==0&&!B(n,o.current)&&(u.preventDefault(),z(G(n),Me(u.key),d.current));break}}},De=u=>{F&&F(u),K&&!u.defaultPrevented&&o.current&&k(o.current.value)},Fe=(u,n)=>{u.preventDefault(),u.stopPropagation(),le(n,Ue(n,O))},Be=u=>{const n=pe(u.currentTarget);u.defaultPrevented||B(u.currentTarget,n)||o.current&&o.current.focus()},re=s.useCallback(()=>{o.current&&ae(o.current),H()},[o,H]),W=s.useMemo(()=>{if(M)return c.jsx(j,{onClick:re,disabled:E,"data-testid":P})},[j,M,P,E,re]),Oe=s.useMemo(()=>{if(W||l)return c.jsxs(c.Fragment,{children:[W,l]})},[l,W]),Ie=Ee||`chips-input-base-generated-id-${ge}`,xe=u=>{if(de(u.target)&&B(d.current,u.target)&&d.current!==u.target)return;const n=pe(u.currentTarget);B(d.current,n)||u.target!==o.current&&u.preventDefault()},qe=u=>{E||Be(u),A?.(u)},Ae=u=>{xe(u),D?.(u)};return c.jsx(Pe,{Component:"div",role:"group","aria-label":r,disabled:E,before:t,after:Oe,status:a,mode:f,maxHeight:C,onClick:qe,onMouseDown:Ae,...i,children:c.jsxs("div",{className:Le(b.host,v!=="regular"&&au[v],te&&b.hasPlaceholder,ue&&b.hasInputValue),ref:Re,onKeyDown:E?void 0:_e,children:[c.jsx("div",{className:b.listBox,ref:d,role:"listbox","aria-orientation":"horizontal","aria-disabled":E,"aria-readonly":N,"aria-label":U,children:O.map((u,n)=>c.jsx(s.Fragment,{children:T({Component:"div",value:u.value,label:u.label,disabled:u.disabled||E,readOnly:u.readOnly||N,className:b.chip,onRemove:Fe,"data-index":n,"data-value":u.value,"data-value-type":typeof u.value,tabIndex:Ve===n?0:-1,role:"option","aria-selected":!0,"aria-posinset":n+1,"aria-setsize":V,"aria-description":"Для удаления используйте Backspace или Delete"},u)},`${typeof u.value}-${u.value}`))}),c.jsx(je,{autoCapitalize:"none",autoComplete:"off",autoCorrect:"off",spellCheck:!1,"aria-label":r,Component:"input",type:"text",id:Ie,getRootRef:o,disabled:E,readOnly:N,value:ue,placeholder:te?he:void 0,onBlur:De,...be})]})})};try{me.displayName="ChipsInputBase",me.__docgenInfo={description:"",displayName:"ChipsInputBase",props:{onClear:{defaultValue:null,description:"Обработчик очистки всех выбранных опций.",name:"onClear",required:!0,type:{name:"() => void"}},onAddChipOption:{defaultValue:null,description:"Обработчик добавления новой опции чипа.",name:"onAddChipOption",required:!0,type:{name:"(value: string) => void"}},onRemoveChipOption:{defaultValue:null,description:"Обработчик удаления опции чипа.",name:"onRemoveChipOption",required:!0,type:{name:"(value: ChipOptionValue | O) => void"}},getRef:{defaultValue:null,description:"@deprecated Since 7.9.0. Вместо этого используйте `slotProps={ input: { getRootRef: ... } }`.",name:"getRef",required:!1,type:{name:"Ref<HTMLInputElement>"}},slotProps:{defaultValue:null,description:"Свойства, которые можно прокинуть внутрь компонента:\n- `root`: свойства для прокидывания в корень компонента;\n- `input`: свойства для прокидывания в поле ввода.",name:"slotProps",required:!1,type:{name:"{ root?: (HTMLAttributes<HTMLDivElement> & HasRootRef<HTMLDivElement> & HasDataAttribute); input?: (InputHTMLAttributes<...> & ... 1 more ... & HasDataAttribute); } | undefined"}},addOnBlur:{defaultValue:null,description:"Добавляет значение в список на событие `onBlur`.",name:"addOnBlur",required:!1,type:{name:"boolean"}},renderChip:{defaultValue:{value:"Используется [Chip](#/Chip)"},description:"Render prop функция для возврата своего компонента.",name:"renderChip",required:!1,type:{name:"RenderChip<O>"}},clearButtonShown:{defaultValue:null,description:"Показывать ли кнопку для очистки значения.",name:"clearButtonShown",required:!1,type:{name:"boolean"}},clearButtonTestId:{defaultValue:null,description:"(e2e) testId кнопки очистки.",name:"clearButtonTestId",required:!1,type:{name:"string"}},ClearButton:{defaultValue:{value:`({
  className,
  onClick,
  ...restProps
}: FormFieldClearButtonProps): React.ReactNode => {
  return (
    <IconButton
      Component="button"
      label="Очистить поле"
      onKeyDown={stopPropagation}
      type="button"
      activeMode="opacity"
      hoverMode="opacity"
      {...restProps}
      className={className}
      onClick={(e) => {
        stopPropagation(e);
        e.preventDefault();
        onClick();
      }}
    >
      <Icon16Cancel />
    </IconButton>
  );
}`},description:"Кастомная кнопка для очистки значения.\nДолжна принимать обязательное свойство `onClick`.",name:"ClearButton",required:!1,type:{name:"ComponentType<FormFieldClearButtonProps>"}},chipsListLabel:{defaultValue:{value:"Выбранные элементы"},description:"`aria-label` для списка выбранных опций.",name:"chipsListLabel",required:!1,type:{name:"string"}},disabled:{defaultValue:null,description:"Блокировка взаимодействия с компонентом.",name:"disabled",required:!1,type:{name:"boolean"}},value:{defaultValue:{value:"[]"},description:"Выбранные опции.",name:"value",required:!1,type:{name:"O[]"}},inputValue:{defaultValue:{value:""},description:"Значение поля ввода.",name:"inputValue",required:!1,type:{name:"string"}},onInputChange:{defaultValue:null,description:"Обработчик изменения значения в поле ввода.",name:"onInputChange",required:!1,type:{name:"OnInputChange"}},delimiter:{defaultValue:null,description:`Символ или строка, которая будет использоваться как разделитель для автоматического создания опций из текста, введенного в поле ввода.
Принимает:
- \`string\` - простая строка
- \`RegExp\` - регулярное выражение
- \`string[]\` - массив строк, по которым нужно разелять ввод.

Работает в двух сценариях:
1. При вводе разделителя - текст до разделителя автоматически преобразуется в новую опцию.
   Например, при \`delimiter=","\` ввод "опция1," создаст опцию "опция1".

2. При вставке из буфера обмена - если вставляемый текст содержит разделители,
   он будет автоматически разбит на несколько опций.
   Например, при \`delimiter=","\` вставка "опция1,опция2,опция3" создаст
   три отдельные опции: "опция1", "опция2" и "опция3".`,name:"delimiter",required:!1,type:{name:"string | RegExp | string[]"}},getRootRef:{defaultValue:null,description:"",name:"getRootRef",required:!1,type:{name:"Ref<HTMLDivElement>"}},align:{defaultValue:null,description:"",name:"align",required:!1,type:{name:"enum",value:[{value:'"center"'},{value:'"left"'},{value:'"right"'}]}},status:{defaultValue:null,description:"Статус отображения поля в форме.",name:"status",required:!1,type:{name:"enum",value:[{value:'"default"'},{value:'"error"'},{value:'"valid"'}]}},mode:{defaultValue:null,description:"Режим отображения.\n\n- `default` — показывает фон, обводку и, при наличии, текст-подсказку.\n- `plain` — показывает только текст-подсказку.",name:"mode",required:!1,type:{name:"enum",value:[{value:'"default"'},{value:'"plain"'}]}},after:{defaultValue:null,description:"Добавляет иконку справа.\n\nРекомендации:\n\n- Используйте следующие размеры иконок `12` | `16` | `20` | `24` | `28`.\n- Используйте [IconButton](https://vkui.io/components/icon-button), если вам нужна иконка, реагируюущая на нажатие.",name:"after",required:!1,type:{name:"ReactNode"}},before:{defaultValue:null,description:"Добавляет иконку слева.\n\nРекомендации:\n\n- Используйте следующие размеры иконок `12` | `16` | `20` | `24` | `28`.\n- Используйте [IconButton](https://vkui.io/components/icon-button), если вам нужна иконка, реагирующая на нажатие.",name:"before",required:!1,type:{name:"ReactNode"}},maxHeight:{defaultValue:null,description:"Максимальная высота поля.",name:"maxHeight",required:!1,type:{name:"number"}}}}}catch{}const lu=(e,t="")=>{try{const l=e.value;e.value=t;const a=e._valueTracker;a&&a.setValue(l);const f=new Event("input",{bubbles:!0});e.dispatchEvent(f)}catch{}},ve=(e,t,l)=>e.map(a=>({...a,label:l(a),value:t(a)}));function ru(e){const t=e.filter(a=>a.length>0);if(t.length===0)return null;const l=t.map(a=>Ce(a));return new RegExp(`(?:${l.join("|")})`)}function ou(e){return e instanceof RegExp?e:typeof e=="string"?new RegExp(Ce(e)):ru(e)}const vu=({value:e,defaultValue:t=J,onChange:l,getOptionLabel:a=Z,getOptionValue:f=Q,getNewOptionData:C=$e,inputValue:O,defaultInputValue:k=S,onInputChange:Y,disabled:T,delimiter:I})=>{const[K,y]=ze({disabled:T,value:e?ve(e,f,a):void 0,defaultValue:ve(t,f,a),onChange:l}),g=s.useRef(null),[$,x]=Se({disabled:T,value:O,defaultValue:k,onChange:Y}),h=s.useCallback((r,m)=>{y(_=>{const v=new Set,A=r.map(i=>{const w=ye(i),F=w?C(i.value,i.label):C(i,typeof i=="string"?i:"");return v.add(F.value),w?{...i,...F}:F}),D=_.filter(i=>!v.has(i.value));return m&&D.push(...A),D})},[y,C]),R=s.useCallback(()=>{g.current&&lu(g.current,"")},[g]),q=s.useCallback(r=>h([r],!0),[h]),L=s.useCallback(r=>h(r,!0),[h]),j=s.useCallback(r=>h([r],!1),[h]),M=s.useCallback(r=>{const m=r.trim();m&&(q(m),R())},[q,R]),P=s.useCallback(()=>{y(t)},[t,y]),H=s.useCallback(()=>{y(J),R()},[R,y]),U=s.useCallback((r,m=!0)=>{const _=r.target.value,v=I?ou(I):null;if(!v||!v.test(_)||!m){x(r);return}const A=_.trim().split(v).map(D=>D.trim()).filter(Boolean);r.target.value="",r.currentTarget.value="",x(r),L(A)},[L,I,x]);return Ye(g,P),{value:K,addOption:q,addOptionFromInput:M,removeOption:j,inputRef:g,inputValue:$,onInputChange:U,clearInput:R,clearOptions:H}};export{me as C,J as D,Q as a,$e as b,S as c,Z as g,ee as r,ve as t,vu as u};
