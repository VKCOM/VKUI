<Overview>
# View

Компонент-контейнер, представляющий собой навигационный слой, содержащий коллекцию `Panel`.

</Overview>

```jsx
import { View, Panel, PanelHeader, Group } from '@vkontakte/vkui';

function Example() {
  const [activePanel, setActivePanel] = React.useState('panel1');

  return (
    <View activePanel={activePanel}>
      <Panel id="panel1">
        <PanelHeader>Panel1</PanelHeader>
        <Group>Panel1 content</Group>
      </Panel>
      <Panel id="panel2">
        <PanelHeader before={<PanelHeaderBack onClick={() => setActivePanel('panel1')} />}>
          Panel2
        </PanelHeader>
        <Group>Panel2 content</Group>
      </Panel>
    </View>
  );
}
```

> **Важно**
>
> Чтобы анимация переходов происходила правильно, порядок [Panel](#/Panel) в вёрстке должен соответствовать их
> подразумеваемому роутингу. Рассмотрим на примере ниже.
>
> ```jsx
> <View activePanel="1">
>   <Panel id="1" />
>   <Panel id="2" />
>   <Panel id="3" />
> </View>
> ```
>
> В примере навигация между панелями должна быть в порядке 1 -> 2 -> 3.

## Уникальный идентификатор

Уникальный идентификатор для `View` можно задать либо с помощью свойства `nav`, либо `id`.
Обязательно указывайте идентификатор, когда используете компонент внутри `Root`.

> Обратите внимание, что при использовании внутри `Root` идентификатор для `View` должен присутствовать
> на элементе, непосредственно переданном в `Root`. Если вы выносите реализацию `View` в отдельный компонент, учитывайте
> это при разработке.
>
> ```jsx
> function ExternalView({ id }) {
>   // Пробрасываем id далее во View
>   return <View id={id}>{/* panels */}</View>;
> }
>
> <Root activeView="external">
>   {/* Передаем id на прямого потомка Root */}
>   <ExternalView id="external" />
> </Root>;
> ```

## Управление `Panel`

Свойство `activePanel` принимает уникальный идентификатор (`id`/`nav`) активного компонента `Panel`.

## Обработчики событий

### Окончание анимации смены

Свойство `onTransition` принимает обработчик, который вызывается при завершении анимации смены активной `Panel`.

```jsx
function transitionHandler({
  // Произошел аыа
  isBack: boolean;
  // Уникальный идентификатор `Panel`, откуда произошел переход
  from: string;
  // Уникальный идентификатор `Panel`, куда произошел переход
  to: string;
}) {
    // обработчик
}

<View onTransition={transitionHandler}>{/* panels */}</View>;
```

### iOS Swipe Back

Свойство `onSwipeBack` Обработчик свайпа назад.
Свойство `onSwipeBackCancel` Обработчик завершения анимации отмененного пользователем свайпа.
Свойство `onSwipeBackStart` Обработчик начала анимации свайпа назад. Чтобы остановить свайп назад, возвращайте "prevent".

В iOS есть возможность свайпнуть от левого края назад, чтобы перейти на предыдущую панель. Для того, чтобы
повторить такое поведение в VKUI, нужно:

- передать во `View` коллбек `onSwipeBack` — он сработает при завершении анимации свайпа. Поменяйте в нем `activePanel` и обновите `history`;
- передать во `View` проп `history` — массив из id панелей в порядке открытия. Например, если пользователь из `main` перешел в `profile`, а оттуда попал в `education`, то `history=['main', 'profile', 'education']`;
- обернуть ваше приложение в `ConfigProvider` — он определит, открыто приложение в `webview` клиента **VK** или в браузере (там есть свой swipe back, который будет конфликтовать с нашим). Для проверки в браузере форсируйте определение `webview`: `<ConfigProvider isWebView>`.

<br />

#### Блокировка свайпа (вариант #1)

Компоненты, которые сами обрабатывают жесты (например, карта или кастомный компонент по типу карусели), могут конфликтовать со свайпбеком. Вот как можно это решить:

- либо повесьте на них свойство `data-vkui-swipe-back={false}`;
- либо вызывайте `event.stopPropagation()` на событие `onStartX` компонента [Touch](#/Touch).

<br />

#### Блокировка свайпа (вариант #2)

Для блокирования свайпа по вашему условию есть коллбек `onSwipeBackStart()` (см. **Свойства и методы**)

```jsx
import * as React from 'react';
import { type ViewProps, View } from '@vkontakte/vkui';

type ViewOnSwipeBackStartProp = Required<ViewProps>['onSwipeBackStart'];

const App = () => {
  const handleSwipeBackStart = React.useCallback<ViewOnSwipeBackStartProp>((activePanel) => {}, []);
  return <View onSwipeBackStart={handleSwipeBackStart} />;
};
```

```jsx
const App = () => {
  const [history, setHistory] = React.useState(['main']);
  const activePanel = history[history.length - 1];

  const go = React.useCallback((panel) => {
    setHistory((prevHistory) => [...prevHistory, panel]);
  }, []);
  const goBack = React.useCallback(() => {
    setHistory((prevHistory) => prevHistory.slice(0, -1));
  }, []);

  const handleProfileClick = React.useCallback(() => go('profile'), [go]);
  const handleSettingsClick = React.useCallback(() => go('settings'), [go]);

  const [userName, setUserName] = React.useState('');
  const [popoutWithRestriction, setPopoutWithRestriction] = React.useState(null);

  const validateUserName = React.useCallback(() => {
    if (userName !== '') {
      return true;
    }

    setPopoutWithRestriction(
      <Alert
        title="Поле Имя не заполнено"
        description="Пожалуйста, заполните его."
        onClose={() => setPopoutWithRestriction(null)}
      />,
    );

    return false;
  }, [userName]);

  const handleSwipeBackStartForPreventIfNeeded = React.useCallback(
    (activePanel) => {
      if (activePanel === 'settings') {
        const isValid = validateUserName();
        return isValid ? undefined : 'prevent';
      }
      return;
    },
    [validateUserName],
  );

  const handleBackForPreventIfNeeded = React.useCallback(() => {
    if (validateUserName()) {
      goBack();
    }
  }, [validateUserName, goBack]);

  return (
    <React.Fragment>
      <View
        history={history}
        activePanel={activePanel}
        onSwipeBackStart={handleSwipeBackStartForPreventIfNeeded}
        onSwipeBack={goBack}
      >
        <Panel id="main">
          <MainPanelContent onProfileClick={handleProfileClick} />
        </Panel>
        <Panel id="profile">
          <ProfilePanelContent onSettingsClick={handleSettingsClick} onBack={goBack} />
        </Panel>
        <Panel id="settings">
          <SettingsPanelContent
            name={userName}
            onChangeName={setUserName}
            onBack={handleBackForPreventIfNeeded}
          />
        </Panel>
      </View>
      {popoutWithRestriction}
    </React.Fragment>
  );
};

const MainPanelContent = ({ onProfileClick }) => {
  return (
    <React.Fragment>
      <PanelHeader>Main</PanelHeader>
      <Group>
        <div style={{ height: 200 }} />
        <CellButton onClick={onProfileClick}>Профиль</CellButton>
        <div style={{ height: 600 }} />
      </Group>
    </React.Fragment>
  );
};

const ProfilePanelContent = ({ onSettingsClick, onBack }) => {
  return (
    <React.Fragment>
      <PanelHeader before={<PanelHeaderBack onClick={onBack} />}>Профиль</PanelHeader>
      <Group>
        <Placeholder>Теперь свайпните от левого края направо, чтобы вернуться</Placeholder>
        <Div style={{ height: 50, background: '#eee' }} data-vkui-swipe-back={false}>
          Здесь свайпбек отключен
        </Div>
      </Group>
      <Group>
        <CellButton onClick={onSettingsClick}>Настройки</CellButton>
      </Group>
      <Group
        header={<Header>Gallery</Header>}
        description="Полностью блокирует свайпбэк (за счёт event.stopPropagation() на onStartX компонента Touch)"
      >
        <Gallery slideWidth="90%" bullets="dark">
          <div style={{ backgroundColor: 'var(--vkui--color_background_negative)' }} />
          <img src="https://placebear.com/1024/640" style={{ display: 'block' }} />
          <div style={{ backgroundColor: 'var(--vkui--color_background_accent)' }} />
        </Gallery>
      </Group>
      <Group
        header={<Header>HorizontalScroll</Header>}
        description="Свайпбэк срабатывает либо если мы тянем за левый край экрана, либо если позиция горизонтального скролла равна нулю"
      >
        <HorizontalScroll>
          {getRandomUsers(15).map((user) => (
            <HorizontalCell key={user.id} size="s" title={user.first_name}>
              <Avatar size={56} src={user.photo_100} />
            </HorizontalCell>
          ))}
        </HorizontalScroll>
      </Group>
    </React.Fragment>
  );
};

const SettingsPanelContent = ({ name, onChangeName, onBack }) => {
  const handleNameChange = React.useCallback(
    (event) => {
      onChangeName(event.target.value.trim());
    },
    [onChangeName],
  );

  return (
    <React.Fragment>
      <PanelHeader before={<PanelHeaderBack onClick={onBack} />}>Настройки</PanelHeader>
      <Group>
        <Placeholder>Пример с блокированием свайпбека пока не будет выполнено условие</Placeholder>
        <FormItem htmlFor="name" top="Имя">
          <Input id="name" value={name} onChange={handleNameChange} />
        </FormItem>
      </Group>
    </React.Fragment>
  );
};

<ConfigProvider platform={'ios'} isWebView>
  <App />
</ConfigProvider>;
```
