<Overview>

# View

Компонент для создания набора экранов из [`Panel`](/components/panel) и возможностью переключаться между ними.

Связанные страницы:

- [Root](/components/root)
- [Epic](/components/epic)
- [Навигация](/overview/navigation)

</Overview>

import { FixedLayoutWrapper } from '@/components/wrappers';

<Playground Wrapper={FixedLayoutWrapper} style={{ height: 415, overflow: 'hidden' }}>

```jsx
const [activePanel, setActivePanel] = useState('panel-1');
const platform = usePlatform();

return (
  <SplitLayout header={platform !== 'vkcom' && <PanelHeader delimiter="none" />}>
    <SplitCol width="100%" stretchedOnMobile autoSpaced>
      <View activePanel={activePanel}>
        <Panel id="panel-1">
          <PanelHeader>Панель 1</PanelHeader>
          <Placeholder stretched>
            <Button appearance="positive" onClick={() => setActivePanel('panel-2')}>
              Перейти к Панель 2
            </Button>
          </Placeholder>
        </Panel>
        <Panel id="panel-2">
          <PanelHeader>Панель 2</PanelHeader>
          <Placeholder stretched>
            <ButtonGroup mode="vertical" align="center">
              <Button appearance="positive" onClick={() => setActivePanel('panel-3')}>
                Перейти к Панель 3
              </Button>
              <Button appearance="negative" onClick={() => setActivePanel('panel-1')}>
                Вернуться к Панель 1
              </Button>
            </ButtonGroup>
          </Placeholder>
        </Panel>
        <Panel id="panel-3">
          <PanelHeader>Панель 3</PanelHeader>
          <Placeholder stretched>
            <ButtonGroup mode="vertical" align="center">
              <Button appearance="negative" onClick={() => setActivePanel('panel-1')}>
                Вернуться к Панель 1
              </Button>
              <Button appearance="negative" onClick={() => setActivePanel('panel-2')}>
                Вернуться к Панель 2
              </Button>
            </ButtonGroup>
          </Placeholder>
        </Panel>
      </View>
    </SplitCol>
  </SplitLayout>
);
```

</Playground>

## Применение компонента

Принимает необходимое количество [`Panel`](/components/panel) с уникальным `id`. Далее `id` с нужным экраном передаётся в свойство
`activePanel`.

```
View
  └─ Panel N
    └─ PanelHeader
    └─ <content>
```

> Если вы выносите экран с [`Panel`](/components/panel) в отдельный компонент, то `id` должен передаваться непосредственно в
> компонент-обёртку и уже после проксироваться в [`Panel`](/components/panel).
>
> ```jsx showLineNumbers {2-3,9-10}
> const MyPanel = ({ id }) => {
>   // проксируем `id` в Panel */
>   return <Panel id={id}>...</Panel>;
> };
>
> export default function App() {
>   return (
>     <View activePanel="my-panel">
>       {/* передаём `id` в компонент-обёртку */}
>       <MyPanel id="my-panel" />
>     </View>
>   );
> }
> ```
>
> Иначе `View` не сможет найти `id` из `activePanel` среди прямых потомков в `children`.

## Особенности анимации

Чтобы анимация переходов происходила правильно, порядок [`Panel`](/components/panel) в вёрстке должен соответствовать их
последовательности переходов.

```jsx
<View activePanel="1">
  <Panel id="1" />
  <Panel id="2" />
  <Panel id="3" />
</View>
```

В примере навигация между панелями должна быть в порядке 1 -> 2 -> 3.

## Обработчики событий

### Окончание анимации смены

Свойство `onTransition` принимает обработчик, который вызывается при завершении анимации смены активной [`Panel`](/components/panel).

```jsx
function transitionHandler({
  // Произошел аыа
  isBack: boolean;
  // Уникальный идентификатор `Panel`, откуда произошел переход
  from: string;
  // Уникальный идентификатор `Panel`, куда произошел переход
  to: string;
}) {
    // обработчик
}

<View onTransition={transitionHandler}>{/* panels */}</View>;
```

### iOS Swipe Back

- `onSwipeBack` – обработчик свайпа назад.
- `onSwipeBackCancel` – обработчик завершения анимации отмененного пользователем свайпа.
- `onSwipeBackStart` – обработчик начала анимации свайпа назад. Чтобы остановить свайп назад, возвращайте `"prevent"`.

В iOS есть возможность свайпнуть от левого края назад, чтобы перейти на предыдущую панель. Для того, чтобы повторить такое поведение
в VKUI, нужно:

- передать во `View` коллбек `onSwipeBack` — он сработает при завершении анимации свайпа. Поменяйте в нем `activePanel` и обновите `history`;
- передать во `View` проп `history` — массив из id панелей в порядке открытия. Например, если пользователь из `main` перешел в `profile`, а оттуда попал в `education`, то `history=['main', 'profile', 'education']`;
- обернуть ваше приложение в [`ConfigProvider`](/components/config-provider) — он определит, открыто приложение в `webview` клиента **VK** или в браузере (там есть свой swipe back, который будет конфликтовать с нашим). Для проверки в браузере форсируйте определение `webview`: `<ConfigProvider isWebView>`.

#### Блокировка свайпа (вариант #1)

Компоненты, которые сами обрабатывают жесты (например, карта или кастомный компонент по типу карусели), могут конфликтовать со свайпбеком. Вот как можно это решить:

- либо повесьте на них свойство `data-vkui-swipe-back={false}`;
- либо вызывайте `event.stopPropagation()` на событие `onStartX` компонента [Touch](/components/touch).

#### Блокировка свайпа (вариант #2)

Для блокирования свайпа по вашему условию есть коллбек `onSwipeBackStart()`.

```tsx
import * as React from 'react';
import { type ViewProps, View } from '@vkontakte/vkui';

type ViewOnSwipeBackStartProp = Required<ViewProps>['onSwipeBackStart'];

const App = () => {
  const handleSwipeBackStart = React.useCallback<ViewOnSwipeBackStartProp>((activePanel) => {}, []);
  return <View onSwipeBackStart={handleSwipeBackStart} />;
};
```

```jsx
const App = () => {
  const [history, setHistory] = React.useState(['main']);
  const activePanel = history[history.length - 1];

  const go = React.useCallback((panel) => {
    setHistory((prevHistory) => [...prevHistory, panel]);
  }, []);
  const goBack = React.useCallback(() => {
    setHistory((prevHistory) => prevHistory.slice(0, -1));
  }, []);

  const handleProfileClick = React.useCallback(() => go('profile'), [go]);
  const handleSettingsClick = React.useCallback(() => go('settings'), [go]);

  const [userName, setUserName] = React.useState('');
  const [popoutWithRestriction, setPopoutWithRestriction] = React.useState(null);

  const validateUserName = React.useCallback(() => {
    if (userName !== '') {
      return true;
    }

    setPopoutWithRestriction(
      <Alert
        title="Поле Имя не заполнено"
        description="Пожалуйста, заполните его."
        onClose={() => setPopoutWithRestriction(null)}
      />,
    );

    return false;
  }, [userName]);

  const handleSwipeBackStartForPreventIfNeeded = React.useCallback(
    (activePanel) => {
      if (activePanel === 'settings') {
        const isValid = validateUserName();
        return isValid ? undefined : 'prevent';
      }
      return;
    },
    [validateUserName],
  );

  const handleBackForPreventIfNeeded = React.useCallback(() => {
    if (validateUserName()) {
      goBack();
    }
  }, [validateUserName, goBack]);

  return (
    <React.Fragment>
      <View
        history={history}
        activePanel={activePanel}
        onSwipeBackStart={handleSwipeBackStartForPreventIfNeeded}
        onSwipeBack={goBack}
      >
        <Panel id="main">
          <MainPanelContent onProfileClick={handleProfileClick} />
        </Panel>
        <Panel id="profile">
          <ProfilePanelContent onSettingsClick={handleSettingsClick} onBack={goBack} />
        </Panel>
        <Panel id="settings">
          <SettingsPanelContent
            name={userName}
            onChangeName={setUserName}
            onBack={handleBackForPreventIfNeeded}
          />
        </Panel>
      </View>
      {popoutWithRestriction}
    </React.Fragment>
  );
};

const MainPanelContent = ({ onProfileClick }) => {
  return (
    <React.Fragment>
      <PanelHeader>Main</PanelHeader>
      <Group>
        <div style={{ height: 200 }} />
        <CellButton onClick={onProfileClick}>Профиль</CellButton>
        <div style={{ height: 600 }} />
      </Group>
    </React.Fragment>
  );
};

const ProfilePanelContent = ({ onSettingsClick, onBack }) => {
  return (
    <React.Fragment>
      <PanelHeader before={<PanelHeaderBack onClick={onBack} />}>Профиль</PanelHeader>
      <Group>
        <Placeholder>Теперь свайпните от левого края направо, чтобы вернуться</Placeholder>
        <Div style={{ height: 50, background: '#eee' }} data-vkui-swipe-back={false}>
          Здесь свайпбек отключен
        </Div>
      </Group>
      <Group>
        <CellButton onClick={onSettingsClick}>Настройки</CellButton>
      </Group>
      <Group
        header={<Header>Gallery</Header>}
        description="Полностью блокирует свайпбэк (за счёт event.stopPropagation() на onStartX компонента Touch)"
      >
        <Gallery slideWidth="90%" bullets="dark">
          <div style={{ backgroundColor: 'var(--vkui--color_background_negative)' }} />
          <img src="https://placebear.com/1024/640" style={{ display: 'block' }} />
          <div style={{ backgroundColor: 'var(--vkui--color_background_accent)' }} />
        </Gallery>
      </Group>
      <Group
        header={<Header>HorizontalScroll</Header>}
        description="Свайпбэк срабатывает либо если мы тянем за левый край экрана, либо если позиция горизонтального скролла равна нулю"
      >
        <HorizontalScroll>
          {getRandomUsers(15).map((user) => (
            <HorizontalCell key={user.id} size="s" title={user.first_name}>
              <Avatar size={56} src={user.photo_100} />
            </HorizontalCell>
          ))}
        </HorizontalScroll>
      </Group>
    </React.Fragment>
  );
};

const SettingsPanelContent = ({ name, onChangeName, onBack }) => {
  const handleNameChange = React.useCallback(
    (event) => {
      onChangeName(event.target.value.trim());
    },
    [onChangeName],
  );

  return (
    <React.Fragment>
      <PanelHeader before={<PanelHeaderBack onClick={onBack} />}>Настройки</PanelHeader>
      <Group>
        <Placeholder>Пример с блокированием свайпбека пока не будет выполнено условие</Placeholder>
        <FormItem htmlFor="name" top="Имя">
          <Input id="name" value={name} onChange={handleNameChange} />
        </FormItem>
      </Group>
    </React.Fragment>
  );
};

export default () => (
  <ConfigProvider platform={'ios'} isWebView>
    <App />
  </ConfigProvider>
);
```
