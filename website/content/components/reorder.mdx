---
description: Компонент для реализации drag-and-drop-перестановки элементов вертикального списка.
---

<Overview group="utils">

# Reorder [tag:component]

Компонент для реализации drag-and-drop-перестановки элементов вертикального списка.

</Overview>

import { BlockWrapper } from '@/components/wrappers';

<Playground Wrapper={BlockWrapper}>

```jsx
const [draggingList, updateDraggingList] = React.useState([
  'Пункт 1',
  'Пункт 2',
  'Пункт 3',
  'Пункт 4',
  'Пункт 5',
]);

return (
  <Reorder
    gap={10}
    items={draggingList}
    setItems={updateDraggingList}
    renderItem={(item, index, dragger) => (
      <div key={item} style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
        {dragger}
        <div>{item}</div>
      </div>
    )}
  />
);
```

</Playground>

> Несколько важных моментов:
>
> - В качестве `items` можно передать массив элементов типа `string`, `number` или объекта с полем `id`.
>   Элементы массива, а также `id` должны быть уникальными в рамках списка.
>   Это нужно для корректного определения `key` у элемента.
> - В `renderItem` третьим параметром передается готовый тригер для перетаскивания, который вы можете встроить в любое место элемента.
>   Если вам нужно кастомизировать компонент, вы можете использовать свойства `triggerLabel` и `TriggerIcon`.
>   Если этого не достаточно, то вы можете самостоятельно отрендерить тригер для перетаскивания. Подробнее можно увидеть в разделе ["Подкомпонентный подход"](/components/reorder#subcomponents)
> - Вы можете использовать функцию `Reorder.onReorder`, чтобы не реализовывать логику изменения порядка элементов.

## Подкомпонентный подход [#subcomponents]

Собрать `Reorder` самостоятельно можно с помощью следующих подкомпонентов:

- `Reorder.Root` – служит flex-оберткой для элементов списка.
  Принимает все основные свойства `Reorder`, кроме `items` и `renderItem`.

- `Reorder.Item` – отвечает за отрисовку элемента списка.

- `Reorder.Trigger` – элемент, на котором обрабатываются жесты/drag. Обычно внутри него ставят `Reorder.TriggerIcon`.

- `Reorder.TriggerIcon` — иконка для визуального хэндла. Поддерживает передачу кастомной иконки через `Icon`.

<Playground Wrapper={BlockWrapper}>

```jsx
const items = [
  {
    avatarUrl: 'https://avatars.githubusercontent.com/u/61377022',
    name: 'Эльдар Мухаметханов',
    screenName: 'e.muhamethanov',
  },
  {
    avatarUrl: 'https://avatars.githubusercontent.com/u/5850354',
    name: 'Ином Мирджамолов',
    screenName: 'inomdzhon',
  },
  {
    avatarUrl: 'https://avatars.githubusercontent.com/u/7431217',
    name: 'Вика Жижонкова',
    screenName: 'BlackySoul',
  },
  {
    avatarUrl: 'https://avatars.githubusercontent.com/u/14944123',
    name: 'Даниил Суворов',
    screenName: 'SevereCloud',
  },
  {
    avatarUrl: 'https://avatars.githubusercontent.com/u/32414396',
    name: 'Никита Денисов',
    screenName: 'qurle',
  },
];

const SimpleCellWrapper = React.useCallback(({ avatarUrl, name, screenName }) => {
  const [dragging, setDragging] = React.useState(false);

  return (
    <Reorder.Item>
      <SimpleCell
        before={
          <Flex align="center" gap={10}>
            <Reorder.Trigger onDragStateChange={setDragging}>
              <Reorder.TriggerIcon>Перенести ячейку</Reorder.TriggerIcon>
            </Reorder.Trigger>
            <Avatar size={48} src={avatarUrl} />
          </Flex>
        }
        after={
          <IconButton label="Написать сообщение">
            <Icon28MessageOutline />
          </IconButton>
        }
        subtitle={screenName}
        style={dragging ? { background: 'var(--vkui--color_background_secondary)' } : undefined}
      >
        {name}
      </SimpleCell>
    </Reorder.Item>
  );
}, []);

const [draggingList, updateDraggingList] = React.useState(items);

const onDragFinish = (swappedItems) =>
  updateDraggingList(Reorder.onReorder(swappedItems, draggingList));

return (
  <Reorder.Root gap={10} onReorder={onDragFinish}>
    {draggingList.map((item) => (
      <SimpleCellWrapper key={item.screenName} {...item} />
    ))}
  </Reorder.Root>
);
```

</Playground>

## Перетаскивание всего элемента целиком

Иногда удобно, чтобы область перетаскивания занимала весь элемент списка — тогда пользователь может начать перемещение, нажав в любом месте карточки
(полезно для мобильных устройств и больших touch-таргетов). Ниже — готовый пример, показывающий этот подход и объясняющий важные нюансы.

Когда использовать:

- Когда элемент списка представляет собой цельный интерактивный блок (карточка, контакт, запись) и вы хотите упростить UX перетаскивания.
- Когда важно обеспечить широкий touch-таргет для перетаскивания на мобильных устройствах.

<Playground Wrapper={BlockWrapper}>

```jsx
const items = [
  {
    avatarUrl: 'https://avatars.githubusercontent.com/u/61377022',
    name: 'Эльдар Мухаметханов',
    screenName: 'e.muhamethanov',
  },
  {
    avatarUrl: 'https://avatars.githubusercontent.com/u/5850354',
    name: 'Ином Мирджамолов',
    screenName: 'inomdzhon',
  },
  {
    avatarUrl: 'https://avatars.githubusercontent.com/u/7431217',
    name: 'Вика Жижонкова',
    screenName: 'BlackySoul',
  },
  {
    avatarUrl: 'https://avatars.githubusercontent.com/u/14944123',
    name: 'Даниил Суворов',
    screenName: 'SevereCloud',
  },
  {
    avatarUrl: 'https://avatars.githubusercontent.com/u/32414396',
    name: 'Никита Денисов',
    screenName: 'qurle',
  },
];

const SimpleCellWrapper = React.useCallback(({ avatarUrl, name, screenName }) => {
  const [dragging, setDragging] = React.useState(false);

  return (
    <Reorder.Item>
      <Reorder.Trigger onDragStateChange={setDragging}>
        <SimpleCell
          before={<Avatar size={48} src={avatarUrl} />}
          after={
            <IconButton label="Написать сообщение">
              <Icon28MessageOutline />
            </IconButton>
          }
          subtitle={screenName}
          style={dragging ? { background: 'var(--vkui--color_background_secondary)' } : undefined}
        >
          {name}
        </SimpleCell>
      </Reorder.Trigger>
    </Reorder.Item>
  );
}, []);

const [draggingList, updateDraggingList] = React.useState(items);

const onDragFinish = (swappedItems) =>
  updateDraggingList(Reorder.onReorder(swappedItems, draggingList));

return (
  <Reorder.Root gap={10} onReorder={onDragFinish}>
    {draggingList.map((item) => (
      <SimpleCellWrapper key={item.screenName} {...item} />
    ))}
  </Reorder.Root>
);
```

</Playground>

## Пользовательская иконка перетаскивания

Чтобы изменить иконку перетаскивания можно использовать свойство `Icon` компонента `Reorder.TriggerIcon`.

```jsx
<Reorder.Item>
  <Reorder.Trigger>
    <Reorder.TriggerIcon Icon={Icon24DragReorderOutline}>Переместить {item}</Reorder.TriggerIcon>
  </Reorder.Trigger>
  <div>{item}</div>
</Reorder.Item>
```

## Свойства и методы [#api]

<PropsTable name={["Group"]}>

### Reorder [#reorder-api]

### Reorder.Root [#reorder-root-api]

### Reorder.Item [#reorder-item-api]

### Reorder.Trigger [#reorder-trigger-api]

### Reorder.TriggerIcon [#reorder-trigger-icon-api]

</PropsTable>
