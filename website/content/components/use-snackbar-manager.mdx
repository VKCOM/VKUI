---
description: Хук, который предоставляет API для управления уведомлениями.
---

<Overview type="hook">

# useSnackbarManager

Хук, который предоставляет API для управления уведомлениями.

Связанные компоненты:

- [Snackbar](/components/snackbar)

</Overview>

import { BlockWrapper } from "@/components/wrappers";

## Параметры

Принимает объект со свойствами:

- `offsetYStart: string | number` - Вертикальный отступ контейнера со снекбарами от верха. Полезно, когда нужно немного сдвинуть верхнюю границу снекбаров.
- `offsetYEnd: string | number` - Вертикальный отступ контейнера со снекбарами от низа. Полезно, когда нужно немного сдвинуть нижнюю границу снекбаров.
- `limit: number` - Максимальное число открытых на одном `placement` уведомлений.
- `queueStrategy: "queue" | "shift"` - Поведение переполнения очереди снекбаров.
  `"queue"` - снекбары не откроются, пока для них не появится место.
  `"shift"` - снекбары форсируют закрытие более старых снекбаров, чтобы освободить место. Значение по умолчанию.
- `zIndex: number | string` - Свойство для установки стиля `z-index` на контейнере снекбаров.

## Возвращаемое значение

1. `SnackbarApi.Api` - API для работы со снекбарами
2. `React.ReactElement | null` - ReactElement, который необходимо встроить в DOM дерево.

### SnackbarApi

- `open(config: SnackbarApi.OpenProps): SnackbarApi.OpenReturn` — Метод для открытия уведомления. Принимает конфиг, возвращает объект [OpenReturn](/components/use-snackbar-manager#open-return).
- `openCustom(payload: CustomSnackbar.Payload | ComponentType<CustomSnackbar.Props>): SnackbarApi.OpenReturn` - Более подробно можно почитать в разделе ["Пользовательские снекбары"](/components/use-snackbar-manager#custom-snackbar).
- `close(id: string): void` — Метод для закрытия снекбара по `id`.
- `closeAll(): void` — Метод для закрытия всех снекбаров.
- `update(id: string, config: SnackbarApi.UpdateProps): void` - Метод для обновления свойств уведомления. Можно поменять любое свойство, кроме 'id' и 'placement'.
- `setLimit(count: number): void` - Метод для изменения максимального числа открытых снекбаров в один момент.
- `setQueueStrategy(behavior: SnackbarApi.QueueStrategy): void` - Метод для изменения поведения переполнения очереди снекбаров.
- `setOffsetYStart(offset: SnackbarApi.OffsetY): void` - Метод для изменения отступа контейнера снекбаров от верха.
- `setOffsetYEnd(offset: SnackbarApi.OffsetY): void` - Метод для изменения отступа контейнера снекбаров снизу.
- `setZIndex(zIndex: number | string): void` - Метод для изменения z-index контейнера снекбаров.

#### OpenReturn [#open-return]

API возвращаемое методами `open` и `openCustom`, которое добавляет дополнительные возможности для взаимодействия с открытыми снекбарами.

- `id: string` - Идентификатор созданного снекбара. Либо переданный при открытии в `props`, либо сгенерированный автоматически `uuidv4`.
- `close: () => void` - Метод для закрытия созданного снекбара.
- `update: (props: SnackbarApi.UpdateProps) => void` - Метод для изменения свойств созданного снекбара.
- `onClose: <R>(resolve?: () => R, reject?: VoidFunction) => Promise<R>` - Метод, который возвращает `Promise`, который сработает, когда снекбар будет закрыт.

## Пример использования

<Playground Wrapper={BlockWrapper}>

```jsx
const [snackbarApi, snackbarHolder] = useSnackbarManager();
const count = useRef(0);

const showSnackbar = () => {
  snackbarApi.open({
    children: `Уведомление показано! ${count.current}`,
  });
  count.current = count.current > 100 ? 0 : count.current + 1;
};

return (
  <>
    <Button onClick={showSnackbar}>Показать уведомление</Button>
    {snackbarHolder}
  </>
);
```

</Playground>

## Пользовательские снекбары [#custom-snackbar]

Иногда нужно, чтобы место вызова снекбара и его верстка были независимы друг от друга.
Для этого в `useSnackbarManager` есть метод **`openCustom`**, который позволяет отрисовать снекбар произвольного вида на базе `Snackbar`.

### Параметры `openCustom`

- **`payload: CustomSnackbar.Payload | ComponentType<CustomSnackbar.Props>`** – принимает либо настройки снекбара в виде объекта типа [CustomSnackbar.Payload](/components/use-snackbar-manager#open-custom-payload),
  либо функцию отрисовки компонента, который принимает свойства типа `CustomSnackbar.Props`.

### `CustomSnackbar.Payload` [#open-custom-payload]

`CustomSnackbar.Payload` описывает свойства вашего пользовательского снекбара.
Это дженерик с параметром **`AdditionalProps extends object`** – любые дополнительные свойства, которые вы хотите передать в свой компонент.

#### Свойства `CustomSnackbar.Payload`:

- **`id?: string`** – идентификатор окна (если не указать, будет сгенерирован автоматически);
- **`baseProps?: SnackbarApi.OpenProps`** – базовые свойства, которые будут проброшены в компонент снекбара;
- **`additionalProps?: AdditionalProps`** – дополнительные свойства, которые будут проброшены в компонент снекбара;
- **`component: ComponentType<CustomSnackbar.Props<AdditionalProps>>`** – React-компонент, который будет рендерить содержимое снекбара.

В компонент автоматически передаются:

- все базовые и необходимые свойства снекбара в свойстве `snackbarProps`,
- `id` снекбара,
- ваши `AdditionalProps`,
- а также служебные методы:
  - **`update(newProps)`** – обновляет свойства снекбара «на лету»;
  - **`close()`** – закрывает текущий снекбар.

> ⚠️ **Важно:**
>
> 1. Следите за корректной типизацией компонентов. Все нужные типы экспортируются вместе с хуком.
> 2. Не используйте в `AdditionalProps` ключи `update` и `close` – они зарезервированы системой.

<Playground Wrapper={BlockWrapper}>

```jsx
const SnackbarComponent = ({
  userName,
  update,
  close,
  snackbarProps,
}: CustomSnackbar.Props<{ userName: string }>) => {
  return (
    <Snackbar action="Хорошо" {...snackbarProps}>
      Отправлено пользователю: {userName}
    </Snackbar>
  );
};

const [snackbarApi, snackbarHolder] = useSnackbarManager();

const showSnackbar = () => {
  snackbarApi.openCustom({
    component: SnackbarComponent,
    additionalProps: {
      userName: "Иван Барышев",
    },
  });
};

return (
  <>
    <Button onClick={showSnackbar}>Показать уведомление</Button>
    {snackbarHolder}
  </>
);
```

</Playground>

### Снекбары без дополнительных свойств

Если вы хотите показать снекбар, не прокидывая ничего в него снаружи, то можете в качестве параметра в `openCustom` прокинуть саму функцию отрисовки компонента.

<Playground Wrapper={BlockWrapper}>

```jsx
const SnackbarComponent = ({
  update,
  close,
  snackbarProps,
}: CustomSnackbar.Props) => {
  return (
    <Snackbar action="Хорошо" {...snackbarProps}>
      Сообщение отправлено Ивану Барышеву
    </Snackbar>
  );
};

const [snackbarApi, snackbarHolder] = useSnackbarManager();

const showSnackbar = () => {
  snackbarApi.openCustom(SnackbarComponent);
};

return (
  <>
    <Button onClick={showSnackbar}>Показать уведомление</Button>
    {snackbarHolder}
  </>
);
```

</Playground>
